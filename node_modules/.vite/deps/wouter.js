import {
  require_react
} from "./chunk-JFTBQ7A7.js";
import {
  __toESM
} from "./chunk-AC2VUBZ6.js";

// node_modules/wouter/react-deps.js
var import_react = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
var useIsomorphicLayoutEffect = canUseDOM ? import_react.useLayoutEffect : import_react.useEffect;

// node_modules/wouter/use-location.js
var relativePath = (base, path = location.pathname) => !path.toLowerCase().indexOf(base.toLowerCase()) ? path.slice(base.length) || "/" : "~" + path;
var eventPopstate = "popstate";
var eventPushState = "pushState";
var eventReplaceState = "replaceState";
var events = [eventPopstate, eventPushState, eventReplaceState];
var use_location_default = ({ base = "" } = {}) => {
  const [{ path }, update] = (0, import_react2.useState)(() => ({ path: relativePath(base) }));
  const prevHash = (0, import_react2.useRef)(path + location.search);
  (0, import_react2.useEffect)(() => {
    const checkForUpdates = () => {
      const pathname = relativePath(base);
      const hash = pathname + location.search;
      if (prevHash.current !== hash) {
        prevHash.current = hash;
        update({ path: pathname });
      }
    };
    events.forEach((e) => addEventListener(e, checkForUpdates));
    checkForUpdates();
    return () => events.forEach((e) => removeEventListener(e, checkForUpdates));
  }, [base]);
  const navigate = (0, import_react2.useCallback)(
    (to, { replace = false } = {}) => history[replace ? eventReplaceState : eventPushState](
      null,
      "",
      // handle nested routers and absolute paths
      to[0] === "~" ? to.slice(1) : base + to
    ),
    [base]
  );
  return [path, navigate];
};
if (typeof history !== "undefined") {
  for (const type of [eventPushState, eventReplaceState]) {
    const original = history[type];
    history[type] = function() {
      const result = original.apply(this, arguments);
      const event = new Event(type);
      event.arguments = arguments;
      dispatchEvent(event);
      return result;
    };
  }
}

// node_modules/wouter/matcher.js
function makeMatcher(makeRegexpFn = pathToRegexp) {
  let cache = {};
  const getRegexp = (pattern) => cache[pattern] || (cache[pattern] = makeRegexpFn(pattern));
  return (pattern, path) => {
    const { regexp, keys } = getRegexp(pattern || "");
    const out = regexp.exec(path);
    if (!out)
      return [false, null];
    const params = keys.reduce((params2, key, i) => {
      params2[key.name] = out[i + 1];
      return params2;
    }, {});
    return [true, params];
  };
}
var escapeRx = (str) => str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
var rxForSegment = (repeat, optional, prefix) => {
  let capture = repeat ? "((?:[^\\/]+?)(?:\\/(?:[^\\/]+?))*)" : "([^\\/]+?)";
  if (optional && prefix)
    capture = "(?:\\/" + capture + ")";
  return capture + (optional ? "?" : "");
};
var pathToRegexp = (pattern) => {
  const groupRx = /:([A-Za-z0-9_]+)([?+*]?)/g;
  let match = null, lastIndex = 0, keys = [], result = "";
  while ((match = groupRx.exec(pattern)) !== null) {
    const [_, segment, mod] = match;
    const repeat = mod === "+" || mod === "*";
    const optional = mod === "?" || mod === "*";
    const prefix = optional && pattern[match.index - 1] === "/" ? 1 : 0;
    const prev = pattern.substring(lastIndex, match.index - prefix);
    keys.push({ name: segment });
    lastIndex = groupRx.lastIndex;
    result += escapeRx(prev) + rxForSegment(repeat, optional, prefix);
  }
  result += escapeRx(pattern.substring(lastIndex));
  return { keys, regexp: new RegExp("^" + result + "(?:\\/)?$", "i") };
};

// node_modules/wouter/index.js
var defaultRouter = {
  hook: use_location_default,
  matcher: makeMatcher(),
  base: ""
};
var RouterCtx = (0, import_react2.createContext)(defaultRouter);
var useRouter = () => (0, import_react2.useContext)(RouterCtx);
var useLocation = () => {
  const router = useRouter();
  return router.hook(router);
};
var useRoute = (pattern) => {
  const [path] = useLocation();
  return useRouter().matcher(pattern, path);
};
var useNavigate = (options) => {
  const navRef = (0, import_react2.useRef)();
  const [, navigate] = useLocation();
  navRef.current = () => navigate(options.to || options.href, options);
  return navRef;
};
var Router = ({ hook, matcher, base = "", parent, children }) => {
  const updateRouter = (router, proto = parent || defaultRouter) => {
    router.hook = hook || proto.hook;
    router.matcher = matcher || proto.matcher;
    router.base = proto.base + base;
    router.parent = parent;
    return router;
  };
  const [value] = (0, import_react2.useState)(() => updateRouter({}));
  useIsomorphicLayoutEffect(() => {
    updateRouter(value);
  });
  return (0, import_react2.createElement)(RouterCtx.Provider, {
    value,
    children
  });
};
var Route = ({ path, match, component, children }) => {
  const useRouteMatch = useRoute(path);
  const [matches, params] = match || useRouteMatch;
  if (!matches)
    return null;
  if (component)
    return (0, import_react2.createElement)(component, { params });
  return typeof children === "function" ? children(params) : children;
};
var Link = (0, import_react2.forwardRef)((props, ref) => {
  const navRef = useNavigate(props);
  const { base } = useRouter();
  let { to, href = to, children, onClick } = props;
  const handleClick = (0, import_react2.useCallback)(
    (event) => {
      if (event.ctrlKey || event.metaKey || event.altKey || event.shiftKey || event.button !== 0)
        return;
      onClick && onClick(event);
      if (!event.defaultPrevented) {
        event.preventDefault();
        navRef.current();
      }
    },
    // navRef is a ref so it never changes
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [onClick]
  );
  const extraProps = {
    // handle nested routers and absolute paths
    href: href[0] === "~" ? href.slice(1) : base + href,
    onClick: handleClick,
    to: null,
    ref
  };
  const jsx = (0, import_react2.isValidElement)(children) ? children : (0, import_react2.createElement)("a", props);
  return (0, import_react2.cloneElement)(jsx, extraProps);
});
var flattenChildren = (children) => {
  return Array.isArray(children) ? [].concat(
    ...children.map(
      (c) => c && c.type === import_react2.Fragment ? flattenChildren(c.props.children) : flattenChildren(c)
    )
  ) : [children];
};
var Switch = ({ children, location: location2 }) => {
  const { matcher } = useRouter();
  const [originalLocation] = useLocation();
  for (const element of flattenChildren(children)) {
    let match = 0;
    if ((0, import_react2.isValidElement)(element) && // we don't require an element to be of type Route,
    // but we do require it to contain a truthy `path` prop.
    // this allows to use different components that wrap Route
    // inside of a switch, for example <AnimatedRoute />.
    (match = element.props.path ? matcher(element.props.path, location2 || originalLocation) : [true, {}])[0])
      return (0, import_react2.cloneElement)(element, { match });
  }
  return null;
};
var Redirect = (props) => {
  const navRef = useNavigate(props);
  useIsomorphicLayoutEffect(() => {
    navRef.current();
  }, []);
  return null;
};
var wouter_default = useRoute;
export {
  Link,
  Redirect,
  Route,
  Router,
  Switch,
  wouter_default as default,
  useLocation,
  useRoute,
  useRouter
};
//# sourceMappingURL=wouter.js.map
